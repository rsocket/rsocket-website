---
slug: /guides/rsocket-py/tutorial/reactivex
title: Reactivex
sidebar_label: Reactivex
---

Up until now we only used the core rsocket python library. We will now simplify some code using the ReactiveX integration.
Well show an implementation using version 4. The implementation with version 3 mostly requires some module import changes.

We will assume basic knowledge of ReactiveX and will not go into detail regarding the specifics of that library.

## Server side

On the server side, the response, stream and channel request types can be simplified using the python ReactiveX library.

### Handler interface

The handler class needs to implement <b>ReactivexHandler</b> instead of <b>RequestHandler</b>. Use the
<b>reactivex_handler_factory</b> to pass the handler to the <b>RSocketServer</b> init argument.
When using routing, use the same <b>RequestRouter</b> instance, but the return values from the registered methods must
match the return values specified on <b>ReactivexHandler</b>

### Request response

For <b>response</b> endpoints, return any <b>Observable</b> with a single value, or a <b>reactivex.empty()</b>

Below is the modified upload endpoin:

```py
import reactivex

@router.response('file.upload')
async def upload_file(payload: Payload, composite_metadata: CompositeMetadata) -> Observable:
    chat_data.files[get_file_name(composite_metadata)] = payload.data
    return reactivex.empty()
```

### Streaming

Python ReactiveX does not natively support any backpressure mechanism. You can either use native observables, or wrap them
with helpers which will provide backpressure.

```py

```

### Channel

```py

```

## Client side

### Client adapter

```py

```

### Request response

```py

```

### Streaming

```py

```

### Channel

```py

```

## RxPy (Reactivex version 3)

```py

```

---
slug: /guides/rsocket-py/tutorial/channels
title: Channels
sidebar_label: Channels
---

In this section we will add basic channel support:
- Joining and leaving channels
- Sending messages to channels

## Server side

### Data-classes
First we will add functionality to store the channel state. Add the following fields to the ChatData class:

```py
from asyncio import Queue
from collections import defaultdict
from dataclasses import dataclass, field
from typing import Dict,  Set
from weakref import WeakSet

@dataclass(frozen=True)
class ChatData:
    ...
    channel_users: Dict[str, Set[SessionId]] = field(default_factory=lambda: defaultdict(WeakSet))
    channel_messages: Dict[str, Queue] = field(default_factory=lambda: defaultdict(Queue))
```

In the <b>channel_users</b> dict, the keys are channel names, and the value is a set of user session ids.
In the <b>channel_messages</b> dict, the keys are the channel names, and the value is a <b>Queue</b> of messages sent by users to the channel.

### Helper methods

Next, we will define some helper methods for managing channel messages:
- <b>ensure_channel_exists</b>: initialize the data for a new channel if it doesn't exist.
- <b>channel_message_delivery</b>: an asyncio task which will deliver channel messages to all the users in a channel.

```py
from asyncio import Queue

def ensure_channel_exists(channel_name: str):
    if channel_name not in chat_data.channel_users:
        chat_data.channel_users[channel_name] = WeakSet()
        chat_data.channel_messages[channel_name] = Queue()
        asyncio.create_task(channel_message_delivery(channel_name))
```

If the channel doesn't exist yet (*Line 4*) It will be added to the <b>channel_users</b> and <b>channel_messages</b> dictionaries.
*Line 7* starts an asyncio task (described below) which will deliver messages sent to the channel, to the channel's users.

```py
import logging

from shared import Message

async def channel_message_delivery(channel_name: str):
    while True:
        try:
            message = await chat_data.channel_messages[channel_name].get()
            for session_id in chat_data.channel_users[channel_name]:
                user_specific_message = Message(user=message.user,
                                                content=message.content,
                                                channel=channel_name)
                chat_data.user_session_by_id[session_id].messages.put_nowait(user_specific_message)
        except Exception as exception:
            logging.error(str(exception), exc_info=True)
```

The above method will loop infinitely and watch the <b>channel_messages</b> queue of the specified
channel (*Line 8*). Upon receiving a message, it will be delivered to all the users in the channel (*Lines 9-13*).

### Join/Leave Channel

Now let's add the channel join/leave handling request-response endpoints.

```py
class ChatUserSession:

    def router_factory(self):
        router = RequestRouter()

        @router.response('channel.join')
        async def join_channel(payload: Payload) -> Awaitable[Payload]:
            channel_name = payload.data.decode('utf-8')
            ensure_channel_exists(channel_name)
            chat_data.channel_users[channel_name].add(self._session.session_id)
            return create_response()

        @router.response('channel.leave')
        async def leave_channel(payload: Payload) -> Awaitable[Payload]:
            channel_name = payload.data.decode('utf-8')
            chat_data.channel_users[channel_name].discard(self._session.session_id)
            return create_response()
```

### Send channel message

Next we add the ability to send channel message. We will modify the <b>send_message</b> method:

```py
class ChatUserSession:

    def router_factory(self):
        router = RequestRouter()

        @router.response('message')
        async def send_message(payload: Payload) -> Awaitable[Payload]:
            message = Message(**json.loads(payload.data))

            logging.info('Received message for user: %s, channel: %s', message.user, message.channel)

            target_message = Message(self._session.username, message.content, message.channel)

            if message.channel is not None:
                await chat_data.channel_messages[message.channel].put(target_message)
            elif message.user is not None:
                session = find_session_by_username(message.user)
                await session.messages.put(target_message)

            return create_response()
```

*Lines 16-20* decide whether it is a private message or a channel message, and add it to the relevant queue.


### Get channel users

```py
class ChatUserSession:

    def router_factory(self):
        router = RequestRouter()

        @router.stream('channel.users')
        async def get_channel_users(payload: Payload) -> Publisher:
            channel_name = utf8_decode(payload.data)

            if channel_name not in chat_data.channel_users:
                return EmptyStream()

            count = len(chat_data.channel_users[channel_name])
            generator = ((Payload(ensure_bytes(find_username_by_session(session_id))), index == count) for
                         (index, session_id) in
                         enumerate(chat_data.channel_users[channel_name], 1))

            return StreamFromGenerator(lambda: generator)
```

## Client side

```py
from typing import List

from rsocket.awaitable.awaitable_rsocket import AwaitableRSocket
from rsocket.extensions.helpers import composite, route
from rsocket.frame_helpers import ensure_bytes
from rsocket.payload import Payload
from rsocket.helpers import utf8_decode

class ChatClient:

    async def join(self, channel_name: str):
        request = Payload(ensure_bytes(channel_name), composite(route('channel.join')))
        await self._rsocket.request_response(request)
        return self

    async def leave(self, channel_name: str):
        request = Payload(ensure_bytes(channel_name), composite(route('channel.leave')))
        await self._rsocket.request_response(request)
        return self

    async def list_channels(self) -> List[str]:
        request = Payload(metadata=composite(route('channels')))
        response = await AwaitableRSocket(self._rsocket).request_stream(request)
        return list(map(lambda _: utf8_decode(_.data), response))

      async def get_users(self, channel_name: str) -> List[str]:
        request = Payload(ensure_bytes(channel_name), composite(route('channel.users')))
        users = await AwaitableRSocket(self._rsocket).request_stream(request)
        return [utf8_decode(user.data) for user in users]
```

*Lines 13-21* define the join/leave methods. They are both simple routed <b>request_response</b> calls, with the channel name as the payload data.

*Lines 23-26* define the list_channels method. This method uses the <b>AwaitableRSocket</b> adapter to simplify getting the response stream as a list.

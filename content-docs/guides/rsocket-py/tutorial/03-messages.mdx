---
slug: /guides/rsocket-py/tutorial/messages
title: Private messages
sidebar_label: Private messages
---

Let's add private messaging between users. We will use a request-stream to listen for new messages from other users.

## Server side

First we add a <b>messages</b> queue on the <b>UserSessionData</b> class for incoming messages:

```py
from dataclasses import dataclass, field
from asyncio import Queue

@dataclass()
class UserSessionData:
    ...
    messages: Queue = field(default_factory=Queue)
```

Line 7 defined a messages queue. These messages will be sent to the connected user if they request them.

Next we will register a request-response endpoint for sending messages:

```py
import json
from typing import Optional, Awaitable

from .models import Message
from more_itertools import first
from rsocket.helpers import create_response
from rsocket.payload import Payload
from rsocket.routing.request_router import RequestRouter

...

def find_session_by_username(username: str) -> Optional[UserSessionData]:
    return first((session for session in chat_data.user_session_by_id.values() if
                  session.username == username), None)

class ChatUserSession:

  def router_factory(self):
      router = RequestRouter()

      ...

      @router.response('message')
      async def send_message(payload: Payload) -> Awaitable[Payload]:
          message = Message(**json.loads(payload.data))

          session = find_session_by_username(message.user)

          await session.messages.put(message)

          return create_response()
```

Finally, we will register a request-stream endpoint for listening to incoming messages:

```py
import asyncio
import json

from reactivestreams.publisher import DefaultPublisher
from reactivestreams.subscriber import Subscriber
from reactivestreams.subscription import DefaultSubscription
from rsocket.extensions.composite_metadata import CompositeMetadata
from rsocket.frame_helpers import ensure_bytes
from rsocket.payload import Payload
from rsocket.routing.request_router import RequestRouter


class ChatUserSession:

  def router_factory(self):
      router = RequestRouter()

      ...

      @router.stream('messages.incoming')
      async def messages_incoming(composite_metadata: CompositeMetadata):
          class MessagePublisher(DefaultPublisher, DefaultSubscription):
              def __init__(self, session: UserSessionData):
                  self._session = session
                  self._sender = None

              def cancel(self):
                  self._sender.cancel()

              def subscribe(self, subscriber: Subscriber):
                  super(MessagePublisher, self).subscribe(subscriber)
                  subscriber.on_subscribe(self)
                  self._sender = asyncio.create_task(self._message_sender())

              async def _message_sender(self):
                  while True:
                      next_message = await self._session.messages.get()
                      next_payload = Payload(ensure_bytes(json.dumps(next_message.__dict__)))
                      self._subscriber.on_next(next_payload)

          return MessagePublisher(self._session)
```

## Client side

First let's add a client method for sending private messages:

```py
import json

from examples.tutorial.step2.models import Message
from rsocket.extensions.helpers import composite, route
from rsocket.frame_helpers import ensure_bytes
from rsocket.payload import Payload

def encode_dataclass(obj):
    return ensure_bytes(json.dumps(obj.__dict__))



class ChatClient:

    ...

    async def private_message(self, username: str, content: str):
        print(f'Sending {content} to user {username}')
        await self._rsocket.request_response(Payload(encode_dataclass(Message(username, content)),
                                                     composite(route('message'))))
```

Next we add a method which will listen for incoming messages:

```py
import asyncio
import json

from examples.tutorial.step2.models import Message
from reactivex import operators
from rsocket.extensions.helpers import composite, route
from rsocket.payload import Payload
from rsocket.reactivex.reactivex_client import ReactiveXClient


class ChatClient:

    ...

    def listen_for_messages(self):
        def print_message(data):
            message = Message(**json.loads(data))
            print(f'{message.user} : {message.content}')

        async def listen_for_messages(client):
            await ReactiveXClient(client).request_stream(
                Payload(metadata=composite(route('messages.incoming')))
            ).pipe(
                operators.do_action(on_next=lambda value: print_message(value.data),
                                    on_error=lambda exception: print(exception)))

        self._listen_task = asyncio.create_task(listen_for_messages(self._rsocket))

    async def wait_for_messages(self):
        messages_done = asyncio.Event()
        self._listen_task.add_done_callback(lambda _: messages_done.set())
        await messages_done.wait()
```

Finally, let's test the new functionality. Modify the <b>main</b> method in the client:

```py
import asyncio

from rsocket.extensions.mimetypes import WellKnownMimeTypes
from rsocket.helpers import single_transport_provider
from rsocket.rsocket_client import RSocketClient
from rsocket.transports.tcp import TransportTCP


async def main():
    connection1 = await asyncio.open_connection('localhost', 6565)

    async with RSocketClient(single_transport_provider(TransportTCP(*connection1)),
                             metadata_encoding=WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA) as client1:
        connection2 = await asyncio.open_connection('localhost', 6565)

        async with RSocketClient(single_transport_provider(TransportTCP(*connection2)),
                                 metadata_encoding=WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA) as client2:
            user1 = ChatClient(client1)
            user2 = ChatClient(client2)

            await user1.login('user1')
            await user2.login('user2')

            user2.listen_for_messages()

            await user1.private_message('user2', 'private message from user1')

            try:
                await asyncio.wait_for(user2.wait_for_messages(), 3)
            except asyncio.TimeoutError:
                pass

            await user2.stop_listening_for_messages()
```

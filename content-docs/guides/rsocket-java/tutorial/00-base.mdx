---
slug: /guides/rsocket-java/tutorial/base
title: Getting started
sidebar_label: Getting started
---

## Application structure

In this step we will set up a minimal code required for both the server and the client.

The application will be composed of:
- Server side
- Client side
- Shared code

See resulting code on [GitHub](https://github.com/rsocket/rsocket-java/tree/master/examples/tutorial/step0)

## Server side

We will set up a simple server to accept connections and respond to the client sending the user's name.
The server will listen on TCP port 6565.

Below is the code for the <b>ServerApplication</b> class:

```java
package io.rsocket.guide;

import io.rsocket.Payload;
import io.rsocket.RSocket;
import io.rsocket.SocketAcceptor;
import io.rsocket.core.RSocketServer;
import io.rsocket.transport.netty.server.TcpServerTransport;
import io.rsocket.util.DefaultPayload;
import reactor.core.publisher.Mono;

public class ServerApplication {

    public static void main(String[] args) {
        final var transport = TcpServerTransport.create(6565);

        final SocketAcceptor socketAcceptor = (setup, sendingSocket) -> Mono.just(new RSocket() {
            public Mono<Payload> requestResponse(Payload payload) {
                return Mono.just(DefaultPayload.create("Welcome to chat, " + payload.getDataUtf8()));
            }
        });

        RSocketServer.create()
                .acceptor(socketAcceptor)
                .bind(transport)
                .block()
                .onClose()
                .block();
    }
}
```

*Lines 22-27* start an RSocket TCP server listening on localhost:6565.

The 2 parameters passed are:
- transport : An instance of a supported connection method. In this case it is at instance of `TcpServerTransport` created in *Line 14*.
- socketAcceptor: A callable which returns an `RSocket` instance wrapped in a `Mono`. This will be used to respond to the client's requests.

*Lines 16-20* Define the `RSocket` service with a single `requestResponse` endpoint at *Lines *17-19*.

The `requestResponse` method receives a single argument containing the payload.
It is an instance of a `Payload` class which contains the data and metadata of the request. The data property is assumed to contain
a UTF-8 encoded string of the username, so is retrieved using `getDataUtf8`.

*Line 18* Takes the username from the `Payload` instance's data and returns it to the client with a "welcome" message.

A response is created using helper methods:
- `DefaultPayload::create` : This creates a payload which is the standard object which wraps all data transferred over RSocket. In our case, only the data property is set.
- `Mono::just` : All RSocket responses must be in the form of streams, either a `Flux` or a `Mono`.

In the example, only the `requestResponse` method of `RSocket` is overridden. In this class, we can override the methods
which handle the 4 RSocket request types:
- `requestResponse`
- `requestStream`
- `requestChannel`
- `fireAndForget`

Check the `RSocket` for other methods which can be implemented.

Next we will look at a simple client which connects to this server.

## Client side

The client will connect to the server, send a single *response* request and disconnect.

Below is the code for the <b>ClientApplication</b> class:

```java
package io.rsocket.guide;

import io.rsocket.core.RSocketConnector;
import io.rsocket.transport.netty.client.TcpClientTransport;
import io.rsocket.util.DefaultPayload;

import java.time.Duration;

public class ClientApplication {

    public static void main(String[] args) {
        final var transport = TcpClientTransport.create("localhost", 6565);

        final var rSocket = RSocketConnector.create()
                .connect(transport)
                .block();

        final var payload = DefaultPayload.create("George");

        rSocket.requestResponse(payload)
                .doOnNext(response -> System.out.println(response.getDataUtf8()))
                .block(Duration.ofMinutes(1));
    }
}
```

*Line 12* instantiates a TCP connection to localhost on port 6565, similar to the one in `ServerApplication`.

*Lines 14-16* instantiates an `RSocket` client.

*Line 18* Wraps the username "George" which the client will send to the server in a `Payload` using the `DefaultPayload.create` factory method

Finally, *Line 20* sends the request to the server and prints (*Line 21*) the received response.

Since RSocket is reactive, and we want to wait for the request to finish before quitting, a call to `block(Duration.ofMinutes(1))` is added to block for 1 minute.

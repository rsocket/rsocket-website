---
slug: /guides/rsocket-java/tutorial/user_session
title: User session
sidebar_label: User session
---

Let's add a server side session to store the logged-in user's state. Later on it will be used to temporarily store
the messages which will be delivered to the client.

See resulting code on [GitHub](https://github.com/rsocket/rsocket-java/tree/master/examples/tutorial/step2)

## Server side

### Data-classes

First we will add a POJO to represent a single user session. Below is the contents of the new `Session` class:

```java
package io.rsocket.guide;

public class Session {
    public String username;

    public String sessionId;
}
```

The username (*Line 4*) will be supplied by the client, and the sessionId (*Line 6*) will be a UUID4 generated by the server.

### Login endpoint

Let's separate the `SocketAcceptor` creation from the `ServerApplication` class. Below is the contents of the new `Server` class:

```java
package io.rsocket.guide.step2;

import io.rsocket.ConnectionSetupPayload;
import io.rsocket.Payload;
import io.rsocket.RSocket;
import io.rsocket.SocketAcceptor;
import io.rsocket.guide.step8.Session;
import io.rsocket.metadata.CompositeMetadata;
import io.rsocket.metadata.RoutingMetadata;
import io.rsocket.metadata.WellKnownMimeType;
import io.rsocket.util.DefaultPayload;
import reactor.core.publisher.Mono;

import java.util.Objects;
import java.util.UUID;

public class Server implements SocketAcceptor {

    @Override
    public Mono<RSocket> accept(ConnectionSetupPayload setup, RSocket sendingSocket) {
        final var session = new Session();
        session.sessionId = UUID.randomUUID().toString();

        return Mono.just(new RSocket() {
            public Mono<Payload> requestResponse(Payload payload) {
                final var route = requireRoute(payload);

                switch (route) {
                    case "login":
                        session.username = payload.getDataUtf8();
                        return Mono.just(DefaultPayload.create(session.sessionId));
                }

                throw new RuntimeException("Unknown requestResponse route " + route);
            }

            private String requireRoute(Payload payload) {
                final var metadata = payload.sliceMetadata();
                final CompositeMetadata compositeMetadata = new CompositeMetadata(metadata, false);

                for (CompositeMetadata.Entry metadatum : compositeMetadata) {
                    if (Objects.requireNonNull(metadatum.getMimeType())
                            .equals(WellKnownMimeType.MESSAGE_RSOCKET_ROUTING.getString())) {
                        return new RoutingMetadata(metadatum.getContent()).iterator().next();
                    }
                }

                throw new IllegalStateException();
            }
        });
    }
}
```

In order to keep a reference to the `Session` we will instantiate it in the `accept` method (*Line 21-22*) which serves as the scope for the current client connection.
The username provided in the login `Payload` will be stored in the session (*Line 30*).

## Client side

We will modify the `Client` to store the username, to use it in output later on:

```py
public Mono<Payload> login(String username) {
    this.username = username;

    final Payload payload = DefaultPayload.create(
            Unpooled.wrappedBuffer(username.getBytes()),
            route("login")
    );
    return rSocket.requestResponse(payload);
}
```

Instead of a greeting from the server, we now receive a session id in the response payload (*Line 8*).

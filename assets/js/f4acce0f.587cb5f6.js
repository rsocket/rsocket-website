"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[653],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>f});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=d(a),u=o,f=m["".concat(s,".").concat(u)]||m[u]||c[u]||r;return a?n.createElement(f,i(i({ref:t},p),{},{components:a})):n.createElement(f,i({ref:t},p))}));function f(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,i=new Array(r);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:o,i[1]=l;for(var d=2;d<r;d++)i[d]=a[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},8084:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>d,toc:()=>m});var n=a(7462),o=a(3366),r=(a(7294),a(3905)),i=["components"],l={slug:"/guides/rsocket-py/tutorial/files",title:"File upload/download",sidebar_label:"File upload/download"},s=void 0,d={unversionedId:"guides/rsocket-py/tutorial/files",id:"guides/rsocket-py/tutorial/files",title:"File upload/download",description:"In this section we will add very basic file upload/download functionality. All files will be stored in memory,",source:"@site/content-docs/guides/rsocket-py/tutorial/04-files.mdx",sourceDirName:"guides/rsocket-py/tutorial",slug:"/guides/rsocket-py/tutorial/files",permalink:"/guides/rsocket-py/tutorial/files",draft:!1,editUrl:"https://github.com/rsocket/rsocket-website/edit/master/content-docs/guides/rsocket-py/tutorial/04-files.mdx",tags:[],version:"current",lastUpdatedBy:"Andrii Maliuta",lastUpdatedAt:1673668570,formattedLastUpdatedAt:"Jan 14, 2023",sidebarPosition:4,frontMatter:{slug:"/guides/rsocket-py/tutorial/files",title:"File upload/download",sidebar_label:"File upload/download"},sidebar:"guides",previous:{title:"Channels",permalink:"/guides/rsocket-py/tutorial/channels"},next:{title:"Statistics",permalink:"/guides/rsocket-py/tutorial/statistics"}},p={},m=[{value:"Shared",id:"shared",level:2},{value:"Server side",id:"server-side",level:2},{value:"Data-classes",id:"data-classes",level:3},{value:"Helper methods",id:"helper-methods",level:3},{value:"Endpoints",id:"endpoints",level:3},{value:"Large file support",id:"large-file-support",level:3},{value:"Client side",id:"client-side",level:2},{value:"Methods",id:"methods",level:3},{value:"Large file support",id:"large-file-support-1",level:3}],c={toc:m};function u(e){var t=e.components,a=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"In this section we will add very basic file upload/download functionality. All files will be stored in memory,\nand downloadable by all users."),(0,r.kt)("p",null,"See resulting code on ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/rsocket/rsocket-py/tree/master/examples/tutorial/step5"},"GitHub")),(0,r.kt)("h2",{id:"shared"},"Shared"),(0,r.kt)("p",null,"First, define a mimetype which will represent file names in the payloads. This will be used by both server and client, so\nplace it in the ",(0,r.kt)("b",null,"shared")," module:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},"chat_filename_mimetype = b'chat/file-name'\n")),(0,r.kt)("h2",{id:"server-side"},"Server side"),(0,r.kt)("h3",{id:"data-classes"},"Data-classes"),(0,r.kt)("p",null,"Next, we need a place to store the files in memory. Add a dictionary to the ",(0,r.kt)("inlineCode",{parentName:"p"},"ChatData")," class to store the files.\nThe keys will be the file names, and the values the file content."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},"from dataclasses import dataclass, field\nfrom typing import Dict\n\n@dataclass(frozen=True)\nclass ChatData:\n    ...\n    files: Dict[str, bytes] = field(default_factory=dict)\n")),(0,r.kt)("h3",{id:"helper-methods"},"Helper methods"),(0,r.kt)("p",null,"Next, define a helper method which extracts the filename from the upload/download payload:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},"from shared import chat_filename_mimetype\nfrom rsocket.extensions.composite_metadata import CompositeMetadata\nfrom rsocket.helpers import utf8_decode\n\ndef get_file_name(composite_metadata: CompositeMetadata):\n    return utf8_decode(composite_metadata.find_by_mimetype(chat_filename_mimetype)[0].content)\n")),(0,r.kt)("p",null,"This helper uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"find_by_mimetype")," method of ",(0,r.kt)("inlineCode",{parentName:"p"},"CompositeMetadata")," to get a list of metadata items with the\nspecified mimetype."),(0,r.kt)("h3",{id:"endpoints"},"Endpoints"),(0,r.kt)("p",null,"Next, register the request-response endpoints for uploading and downloading files, and for retrieving a list of\navailable files:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},"from typing import Awaitable\n\nfrom shared import chat_filename_mimetype\nfrom rsocket.extensions.composite_metadata import CompositeMetadata\nfrom rsocket.extensions.helpers import composite, metadata_item\nfrom rsocket.frame_helpers import ensure_bytes\nfrom rsocket.helpers import create_response\nfrom rsocket.payload import Payload\nfrom rsocket.routing.request_router import RequestRouter\nfrom rsocket.streams.stream_from_generator import StreamFromGenerator\n\nclass ChatUserSession:\n\n    def router_factory(self):\n        router = RequestRouter()\n\n        @router.response('file.upload')\n        async def upload_file(payload: Payload, composite_metadata: CompositeMetadata) -> Awaitable[Payload]:\n            chat_data.files[get_file_name(composite_metadata)] = payload.data\n            return create_response()\n\n        @router.response('file.download')\n        async def download_file(composite_metadata: CompositeMetadata) -> Awaitable[Payload]:\n            file_name = get_file_name(composite_metadata)\n            return create_response(chat_data.files[file_name],\n                                   composite(metadata_item(ensure_bytes(file_name), chat_filename_mimetype)))\n\n        @router.stream('files')\n        async def get_file_names() -> Publisher:\n            count = len(chat_data.files)\n            generator = ((Payload(ensure_bytes(file_name)), index == count) for (index, file_name) in\n                         enumerate(chat_data.files.keys(), 1))\n            return StreamFromGenerator(lambda: generator)\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"upload_file")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"download_file")," methods (",(0,r.kt)("em",{parentName:"p"},"Lines 18-27"),") extract the filename from the metadata using the helper method we created,\nand set and get the file content from the ",(0,r.kt)("inlineCode",{parentName:"p"},"chat_data")," storage respectively."),(0,r.kt)("p",null,"In this section we introduce the second argument which can be passed to routed endpoints. If the session is set up to use\ncomposite metadata, the ",(0,r.kt)("inlineCode",{parentName:"p"},"composite_metadata")," parameter will contain a parsed structure of the metadata in the request payload."),(0,r.kt)("p",null,"Line 34 uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"StreamFromGenerator")," helper which creates a stream publisher from a generator factory."),(0,r.kt)("p",null,"The generator must return a tuple of two values for each iteration:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Payload instance"),(0,r.kt)("li",{parentName:"ul"},"boolean value denoting if it is the last element in the generator.\nThe argument for the helper class is a method which returns a generator, not the generator itself.")),(0,r.kt)("h3",{id:"large-file-support"},"Large file support"),(0,r.kt)("p",null,"In the ",(0,r.kt)("inlineCode",{parentName:"p"},"download_file")," method (Line 24), even though the frame size limit is 16MB, larger files can be downloaded.\nTo allow this, fragmentation must be enabled. This is done by adding the ",(0,r.kt)("inlineCode",{parentName:"p"},"fragment_size_bytes")," argument to the ",(0,r.kt)("inlineCode",{parentName:"p"},"RSocketServer")," instantiation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},"from rsocket.rsocket_server import RSocketServer\nfrom rsocket.transports.tcp import TransportTCP\n\ndef session(*connection):\n        RSocketServer(TransportTCP(*connection),\n                      handler_factory=handler_factory,\n                      fragment_size_bytes=1_000_000)\n")),(0,r.kt)("h2",{id:"client-side"},"Client side"),(0,r.kt)("h3",{id:"methods"},"Methods"),(0,r.kt)("p",null,"On the client side, we will add 3 methods to access the new server functionality:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"upload")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"download")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"list_files"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},"from typing import List\n\nfrom rsocket.awaitable.awaitable_rsocket import AwaitableRSocket\nfrom rsocket.extensions.helpers import composite, route, metadata_item\nfrom rsocket.frame_helpers import ensure_bytes\nfrom rsocket.helpers import utf8_decode\nfrom rsocket.payload import Payload\n\nfrom shared import chat_filename_mimetype\n\nclass ChatClient:\n\n    async def upload(self, file_name: str, content: bytes):\n        await self._rsocket.request_response(Payload(content, composite(\n            route('file.upload'),\n            metadata_item(ensure_bytes(file_name), chat_filename_mimetype)\n        )))\n\n    async def download(self, file_name: str):\n        return await self._rsocket.request_response(Payload(\n            metadata=composite(\n                route('file.download'),\n                metadata_item(ensure_bytes(file_name), chat_filename_mimetype)\n            )))\n\n    async def list_files(self) -> List[str]:\n        request = Payload(metadata=composite(route('files')))\n        response = await AwaitableRSocket(self._rsocket).request_stream(request)\n        return list(map(lambda _: utf8_decode(_.data), response))\n")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Lines 13-17")," define the upload method. the ",(0,r.kt)("inlineCode",{parentName:"p"},"Payload")," of the request-response consists of a body with the file's contents,\nand metadata which contains routing and the filename. To specify the filename a custom mimetype was used ",(0,r.kt)("strong",{parentName:"p"},"chat/file-name"),".\nThis mime type was used to create a metadata item using the ",(0,r.kt)("inlineCode",{parentName:"p"},"metadata_item")," method. the ",(0,r.kt)("inlineCode",{parentName:"p"},"composite")," method was used to combine\nthe two metadata items to the complete metadata of the payload."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Lines 19-24")," define the download method. It is similar to the upload method, except for the absence of the payload data,\nand a different route: 'file.download'."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Lines 26-32")," defines the list_files method. Same as the ",(0,r.kt)("inlineCode",{parentName:"p"},"list_channels")," method in the previous section,\nit uses the request-stream 'files' endpoint to get a list of files."),(0,r.kt)("h3",{id:"large-file-support-1"},"Large file support"),(0,r.kt)("p",null,"Same as on the server size, fragmentation must be enabled to allow uploading files larger than 16MB.\nThis is done by adding the ",(0,r.kt)("inlineCode",{parentName:"p"},"fragment_size_bytes")," argument to the ",(0,r.kt)("inlineCode",{parentName:"p"},"RSocketClient")," instantiation. Do this for both clients:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},"from rsocket.extensions.mimetypes import WellKnownMimeTypes\nfrom rsocket.helpers import single_transport_provider\nfrom rsocket.rsocket_client import RSocketClient\nfrom rsocket.transports.tcp import TransportTCP\n\nasync with RSocketClient(single_transport_provider(TransportTCP(*connection1)),\n                             metadata_encoding=WellKnownMimeTypes.MESSAGE_RSOCKET_COMPOSITE_METADATA,\n                             fragment_size_bytes=1_000_000) as client1:\n    ...\n")),(0,r.kt)("p",null,"We will try out the new functionality with the following code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},"async def files_example(user1: ChatClient, user2: ChatClient):\n    file_contents = b'abcdefg1234567'\n    file_name = 'file_name_1.txt'\n\n    await user1.upload(file_name, file_contents)\n\n    print(f'Files: {await user1.list_files()}')\n\n    download = await user2.download(file_name)\n\n    if download.data != file_contents:\n        raise Exception('File download failed')\n    else:\n        print(f'Downloaded file: {len(download.data)} bytes')\n")),(0,r.kt)("p",null,"call the ",(0,r.kt)("inlineCode",{parentName:"p"},"files_example")," method from the main client method."))}u.isMDXComponent=!0}}]);
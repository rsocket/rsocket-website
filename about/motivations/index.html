<!doctype html>
<html class="docs-version-current" lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.6">
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-122364851-2"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-122364851-2",{})</script>
<link rel="stylesheet" href="https://docusaurus.io/style.css">
<link rel="stylesheet" href="https://css.link">
<script src="https://docusaurus.io/slash.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js" async></script><title data-react-helmet="true">Motivations | RSocket</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://rsocket.io/about/motivations"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:image" content="https://rsocket.io/img/social/rsocket-io-facebook-og.jpg"><meta data-react-helmet="true" name="twitter:image" content="https://rsocket.io/img/social/rsocket-io-twitter-card.jpg"><meta data-react-helmet="true" name="twitter:site" content="@rsocket"><meta data-react-helmet="true" property="og:title" content="Motivations | RSocket"><meta data-react-helmet="true" name="description" content="Large, distributed systems are often implemented in a modular fashion by different teams using a variety of technologies and programming languages. The pieces need to communicate reliably and support rapid, independent evolution. Effective and scalable communication between modules is a crucial concern in distributed systems. It significantly affects how much latency users experience and the amount of resources required to build and run the system."><meta data-react-helmet="true" property="og:description" content="Large, distributed systems are often implemented in a modular fashion by different teams using a variety of technologies and programming languages. The pieces need to communicate reliably and support rapid, independent evolution. Effective and scalable communication between modules is a crucial concern in distributed systems. It significantly affects how much latency users experience and the amount of resources required to build and run the system."><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.png"><link data-react-helmet="true" rel="canonical" href="https://rsocket.io/about/motivations"><link data-react-helmet="true" rel="alternate" href="https://rsocket.io/about/motivations" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://rsocket.io/about/motivations" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.96761f9c.css">
<link rel="preload" href="/assets/js/runtime~main.bd5a8bb2.js" as="script">
<link rel="preload" href="/assets/js/main.d9d3646b.js" as="script">
</head>
<body>
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):(window.matchMedia("(prefers-color-scheme: light)").matches,e("light"))}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="https://rsocket.io/img/r-socket-pink.svg" alt="RSocket" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="https://rsocket.io/img/r-socket-pink.svg" alt="RSocket" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">RSocket</b></a><a class="navbar__item navbar__link" href="/about/faq">About</a><a class="navbar__item navbar__link" href="/guides">Guides</a><a href="https://github.com/rsocket" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><a class="navbar__item navbar__link" href="/help">Help</a></div><div class="navbar__items navbar__items--right"><div class="react-toggle toggle_3Zt9 react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT">üåú</span></div><div class="react-toggle-track-x"><span class="toggle_71bT">üåû</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docs-wrapper docs-doc-page"><div class="docPage_31aa"><button class="clean-btn backToTopButton_35hR" type="button"><svg viewBox="0 0 24 24" width="28"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z" fill="currentColor"></path></svg></button><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">About</a><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/about/faq">FAQ</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/about/motivations">Motivations</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/about/protocol">Protocol</a></li><li class="theme-doc-sidebar-item-link menu__list-item"><a class="menu__link" tabindex="0" href="/about/implementations">Implementations</a></li></ul></li><li class="theme-doc-sidebar-item-category menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">Guides</a></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="tocCollapsible_1PrD theme-doc-toc-mobile tocMobile_3Hoh"><button type="button" class="clean-btn tocCollapsibleButton_2O1e">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Motivations</h1></header><p>Large, distributed systems are often implemented in a modular fashion by different teams using a variety of technologies and programming languages. The pieces need to communicate reliably and support rapid, independent evolution. Effective and scalable communication between modules is a crucial concern in distributed systems. It significantly affects how much latency users experience and the amount of resources required to build and run the system.</p><p>Architectural patterns documented in the <a href="http://www.reactivemanifesto.org" target="_blank" rel="noopener noreferrer" title="We want systems that are Responsive, Resilient, Elastic, and Message Driven. We call these Reactive Systems.">Reactive Manifesto</a> and implemented in libraries such as <a href="http://www.reactive-streams.org" target="_blank" rel="noopener noreferrer" title="Reactive Streams is an initiative to provide a standard for asynchronous stream processing with non-blocking back pressure.">Reactive Streams</a> and <a href="http://www.reactivex.io" target="_blank" rel="noopener noreferrer" title="ReactiveX is an API for asynchronous programming with observable streams.">Reactive Extensions</a> favor asynchronous messaging and embrace communication patterns beyond request/response. This ‚ÄúRSocket‚Äù protocol is a formal communication protocol that embraces the ‚Äúreactive‚Äù principles.</p><p>Following are our motivations for defining a new protocol:</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="message-driven"></a>Message Driven<a class="hash-link" href="#message-driven" title="Direct link to heading">#</a></h2><p>Network communication is asynchronous. The RSocket protocol embraces this and models all communication as multiplexed streams of messages over a single network connection, and never synchronously blocks while waiting for a response.</p><p>The <a href="http://www.reactivemanifesto.org" target="_blank" rel="noopener noreferrer" title="We want systems that are Responsive, Resilient, Elastic, and Message Driven. We call these Reactive Systems.">Reactive Manifesto</a> states:</p><blockquote><p>Reactive Systems rely on asynchronous message-passing to establish a boundary between components that ensures loose coupling, isolation, location transparency, and provides the means to delegate errors as messages. Employing explicit message-passing enables load management, elasticity, and flow control by shaping and monitoring the message queues in the system and applying back-pressure when necessary. ‚Ä¶ Non-blocking communication allows recipients to only consume resources while active, leading to less system overhead.</p></blockquote><p>Additionally, the <a href="https://http2.github.io/faq/#why-is-http2-multiplexed" target="_blank" rel="noopener noreferrer">HTTP/2 FAQ</a> does a good job of explaining the motivations for adopting a message-oriented protocol in the form of multiplexing over persistent connections:</p><blockquote><p>HTTP/1.x has a problem called ‚Äúhead-of-line blocking,‚Äù where effectively only one request can be outstanding on a connection at a time.</p></blockquote><blockquote><p>HTTP/1.1 tried to fix this with pipelining, but it didn‚Äôt completely address the problem (a large or slow response can still block others behind it). Additionally, pipelining has been found very difficult to deploy, because many intermediaries and servers don‚Äôt process it correctly.</p></blockquote><blockquote><p>This forces clients to use a number of heuristics (often guessing) to determine what requests to put on which connection to the origin when; since it‚Äôs common for a page to load 10 times (or more) the number of available connections, this can severely impact performance, often resulting in a ‚Äúwaterfall‚Äù of blocked requests.</p></blockquote><blockquote><p>Multiplexing addresses these problems by allowing multiple request and response messages to be in flight at the same time; it‚Äôs even possible to intermingle parts of one message with another on the wire.</p></blockquote><blockquote><p>This, in turn, allows a client to use just one connection per origin to load a page.</p></blockquote><p>The FAQ continues, discussing persistent connections:</p><blockquote><p>With HTTP/1, browsers open between four and eight connections per origin. Since many sites use multiple origins, this could mean that a single page load opens more than thirty connections.</p></blockquote><blockquote><p>One application opening so many connections simultaneously breaks a lot of the assumptions that TCP was built upon; since each connection will start a flood of data in the response, there‚Äôs a real risk that buffers in the intervening network will overflow, causing a congestion event and retransmits.</p></blockquote><blockquote><p>Additionally, using so many connections unfairly monopolizes network resources, ‚Äústealing‚Äù them from other, better-behaved applications (e.g., VoIP).</p></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="interaction-models"></a>Interaction Models<a class="hash-link" href="#interaction-models" title="Direct link to heading">#</a></h2><p>An inappropriate protocol increases the costs of developing a system. It can be a mismatched abstraction that forces the design of the system into the mold it allows. This forces developers to spend extra time working around its shortcomings to handle errors and achieve acceptable performance. In a polyglot environment this problem is amplified as different languages will use different approaches to solve this problem, which requires extra coordination among teams. To date the de facto standard is HTTP and everything is a request/response. In some cases this might not be the ideal communication model for a given feature.</p><p>One such example is push notifications. Using request/response forces an application to do polling, where the client consistently sends requests to check the server for data. One does not need to look far to find examples of applications doing high volumes of requests/second just to poll and be told there is nothing for them. This is wasteful for clients, servers, and networks; costs money; and increases infrastructure size, operational complexity, and thus availability. It also generally adds latency to the user experience in receiving a notification, as polling is scaled back to longer intervals in an attempt to reduce costs.</p><p>For this and other reasons, RSocket is not limited to just one interaction model. The various supported interaction models described below open up powerful new possibilities for system design:</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="fire-and-forget"></a>Fire-and-Forget<a class="hash-link" href="#fire-and-forget" title="Direct link to heading">#</a></h3><p>Fire-and-forget is an optimization of request/response that is useful when a response is not needed. It allows for significant performance optimizations, not just in saved network usage by skipping the response, but also in client and server processing time as no bookkeeping is needed to wait for and associate a response or cancellation request.</p><p>This interaction model is useful for use cases that support lossiness, such as non-critical event logging.</p><p>Usage can be thought of like this:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#9CDCFE"><span class="token plain">Future&lt;Void&gt; completionSignalOfSend = socketClient.fireAndForget(message);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="requestresponse-single-response"></a>Request/Response (single-response)<a class="hash-link" href="#requestresponse-single-response" title="Direct link to heading">#</a></h3><p>Standard request/response semantics are still supported, and still expected to represent the majority of requests over a RSocket connection. These request/response interactions can be considered optimized ‚Äústreams of only 1 response‚Äù, and are asynchronous messages multiplexed over a single connection.</p><p>The consumer ‚Äúwaits‚Äù for the response message, so it looks like a typical request/response, but underneath it never synchronously blocks.</p><p>Usage can be thought of like this:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#9CDCFE"><span class="token plain">Future&lt;Payload&gt; response = socketClient.requestResponse(requestPayload);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="requeststream-multi-response-finite"></a>Request/Stream (multi-response, finite)<a class="hash-link" href="#requeststream-multi-response-finite" title="Direct link to heading">#</a></h3><p>Extending from request/response is request/stream, which allows multiple messages to be streamed back. Think of this as a ‚Äúcollection‚Äù or ‚Äúlist‚Äù response, but instead of getting back all the data as a single response, each element is streamed back in order.</p><p>Use cases could include things like:</p><ul><li>fetching a list of videos</li><li>fetching products in a catalog</li><li>retrieving a file line-by-line</li></ul><p>Usage can be thought of like this:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#9CDCFE"><span class="token plain">Publisher&lt;Payload&gt; response = socketClient.requestStream(requestPayload);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="channel"></a>Channel<a class="hash-link" href="#channel" title="Direct link to heading">#</a></h3><p>A channel is bi-directional, with a stream of messages in both directions.</p><p>An example use case that benefits from this interaction model is:</p><ul><li>client requests a stream of data that initially bursts the current view of the world</li><li>deltas/diffs are emitted from server to client as changes occur</li><li>client updates the subscription over time to add/remove criteria/topics/etc.</li></ul><p>Without a bi-directional channel, the client would have to cancel the initial request, re-request, and receive all data from scratch, rather than just updating the subscription and efficiently getting just the difference.</p><p>Usage can be thought of like this:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly java"><pre tabindex="0" class="prism-code language-java codeBlock_23N8 thin-scrollbar" style="color:#9CDCFE;background-color:#1E1E1E"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#9CDCFE"><span class="token plain">Publisher&lt;Payload&gt; output = socketClient.requestChannel(Publisher&lt;Payload&gt; input);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="behaviors"></a>Behaviors<a class="hash-link" href="#behaviors" title="Direct link to heading">#</a></h2><p>Beyond the interaction models above, there are other behaviors that can benefit applications and system efficiency.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="single-response-vs-multi-response"></a>Single-Response vs. Multi-Response<a class="hash-link" href="#single-response-vs-multi-response" title="Direct link to heading">#</a></h3><p>One key difference between single-response and multi-response is how the RSocket stack delivers data to the application: A single-response might be carried across multiple frames, and be part of a larger RSocket connection that is streaming multiple messages multiplexed. But single-response means the application only gets its data when the entire response is received. While multi-response delivers it piecemeal. This could allow the user to design its service with multi-response in mind, and then the client can start processing the data as soon as it receives the first chunk.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="bi-directional"></a>Bi-Directional<a class="hash-link" href="#bi-directional" title="Direct link to heading">#</a></h3><p>RSocket supports bi-directional requests where both client and server can act as requester or responder. This allows a client (such as a user device) to act as a responder to requests from the server.</p><p>For example, a server could query clients for trace debug information, state, etc. This can be used to reduce infrastructure scaling requirements by allowing server-side to query when needed instead of having millions/billions of clients constantly submitting data that may only occasionally be needed. This also opens up future interaction models currently not envisioned between client and server.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="cancellation"></a>Cancellation<a class="hash-link" href="#cancellation" title="Direct link to heading">#</a></h2><p>All streams (including request/response) support cancellation to allow efficient cleanup of server (responder) resources. This means that when a client cancels, or walks away, servers are given the chance to terminate work early. This is essential with interaction models such as streams and subscriptions, but is even useful with request/response to allow efficient adoption of approaches such as ‚Äúbackup requests‚Äù to tame tail latency (more information <a href="http://highscalability.com/blog/2012/3/12/google-taming-the-long-latency-tail-when-more-machines-equal.html" target="_blank" rel="noopener noreferrer">here</a>, <a href="http://highscalability.com/blog/2012/6/18/google-on-latency-tolerant-systems-making-a-predictable-whol.html" target="_blank" rel="noopener noreferrer">here</a>, <a href="http://www.bailis.org/blog/doing-redundant-work-to-speed-up-distributed-queries/" target="_blank" rel="noopener noreferrer">here</a>, and <a href="http://static.googleusercontent.com/external_content/untrusted_dlcp/research.google.com/en/us/people/jeff/Stanford-DL-Nov-2010.pdf" target="_blank" rel="noopener noreferrer">here</a>).</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="resumability"></a>Resumability<a class="hash-link" href="#resumability" title="Direct link to heading">#</a></h2><p>With long-lived streams, particularly those serving subscriptions from mobile clients, network disconnects can significantly impact cost and performance if all subscriptions must be re-established. This is particularly egregious when the network is immediately reconnected, or when switched between Wifi and cell networks.</p><p>RSocket supports session resumption, allowing a simple handshake to resume a client/server session over a new transport connection.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="application-flow-control"></a>Application Flow Control<a class="hash-link" href="#application-flow-control" title="Direct link to heading">#</a></h2><p>RSocket supports two forms of application-level flow control to help protect both client and server resources from being overwhelmed: ‚ÄúReactive Streams‚Äù <code>request(n)</code> async pull, and leasing.</p><p>This protocol is designed for use both in datacenter, server-to-server use cases, as well as server-to-device use cases over the internet, such as to mobile devices or browsers.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="reactive-streams-requestn-async-pull"></a>‚ÄúReactive Streams‚Äù <code>request(n)</code> Async Pull<a class="hash-link" href="#reactive-streams-requestn-async-pull" title="Direct link to heading">#</a></h3><p>This first form of flow control is suited to both server-to-server and server-to-device use cases. It is inspired by the Reactive Streams <a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.0/README.md#3-subscription-code" target="_blank" rel="noopener noreferrer">Subscription.request(n)</a> behavior. <a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener noreferrer" title="RxJava is a library for composing asynchronous and event-based programs using observable sequences for the Java VM.">RxJava</a>, <a href="https://github.com/reactor/reactor" target="_blank" rel="noopener noreferrer" title="Reactive foundations for apps and frameworks and reactive extensions, with Mono (1 element) and Flux (n elements) types.">Reactor</a>, and <a href="https://doc.akka.io/about/akka/2.4/scala/stream/index.html" target="_blank" rel="noopener noreferrer" title="An intuitive and safe way to formulate stream processing setups such that we can then execute them efficiently and with bounded resource usage.">Akka Streams</a> are examples of implementations using this form of ‚Äúasync pull-push‚Äù flow control.</p><p>RSocket allows for the <code>request(n)</code> signal to be composed over network boundaries from requester to responder (typically client to server). This controls the flow of emission from responder to requester using Reactive Streams semantics at the application level and enables the use of bounded buffers so rate-of-flow adjusts to application consumption and does not rely solely on transport and network buffering.</p><p>This same data type and approach has been adopted into Java 9 in <a href="https://docs.oracle.com/javase/9/about/api/java/util/concurrent/Flow.Subscription.html" target="_blank" rel="noopener noreferrer">the <code>java.util.concurrent.Flow</code> suite of types</a>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="leasing"></a>Leasing<a class="hash-link" href="#leasing" title="Direct link to heading">#</a></h3><p>The second form of flow control is primarily focused on server-to-server use cases in a data center. When enabled, a responder (typically a server) can issue leases to the requester based upon its knowledge of its capacity in order to control requests rates. On the requester side, this enables application-level load balancing for sending messages only to responders (servers) that have signalled capacity. This signal from server to client allows for more intelligent routing and load-balancing algorithms in data centers with clusters of machines.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="polyglot-support"></a>Polyglot Support<a class="hash-link" href="#polyglot-support" title="Direct link to heading">#</a></h2><p>Many of the motivations above can be achieved by leveraging existing protocols, libraries, and techniques. However, this often ends up being tightly coupled with specific implementations that must be agreed upon across languages, platforms, and tech stacks.</p><p>In contrast, formalizing the interaction models and flow control behaviors into a protocol provides a contract between implementations in different languages. This in turn improves polyglot interactions in a broader set of behaviors than the ubiquitous HTTP/1.1 request/response, while also enabling Reactive Streams application-level flow control across languages (rather than just in Java, for example, where Reactive Streams was originally defined).</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="transport-layer-flexibility"></a>Transport Layer Flexibility<a class="hash-link" href="#transport-layer-flexibility" title="Direct link to heading">#</a></h2><p>Just as HTTP request/response is not the only way applications can or should communicate, TCP is not the only transport layer available, and not the best for all use cases. Thus, RSocket allows you to swap the underlying transport layer based on environment, device capabilities, and performance needs. RSocket (the application protocol) targets WebSockets, TCP, and <a href="https://github.com/real-logic/Aeron" target="_blank" rel="noopener noreferrer" title="Efficient reliable UDP unicast, UDP multicast, and IPC message transport.">Aeron</a>, and is expected to be usable over any transport layer with TCP-like characteristics, such as <a href="https://www.chromium.org/quic" target="_blank" rel="noopener noreferrer" title="QUIC is a new transport which reduces latency compared to that of TCP.">QUIC</a>.</p><p>Perhaps more importantly though, it makes TCP, WebSockets, and Aeron usable without significant effort. For example, use of WebSockets is often appealing, but all it exposes is framing semantics, so using it requires the definition of an application protocol. This is generally overwhelming and requires a lot of effort. TCP doesn‚Äôt even provide framing. Thus, most applications end up using HTTP/1.1 and sticking to request/response and missing out on the benefits of interaction models beyond synchronous request/response.</p><p>For this reason, RSocket defines application-layer semantics over these network transports to allow choosing them when they are appropriate. Later in this document is a brief comparison with other protocols that were explored while trying to leverage WebSockets and Aeron before determining that a new application protocol was wanted.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="efficiency--performance"></a>Efficiency &amp; Performance<a class="hash-link" href="#efficiency--performance" title="Direct link to heading">#</a></h2><p>A protocol that uses network resources inefficiently (repeated handshakes and connection setup and tear down overhead, bloated message format, etc.) can greatly increase the perceived latency of a system. Also, without flow control semantics, a single poorly-written module can overrun the rest of the system when dependent services slow down, potentially causing retry storms that put further pressure on the system. <a href="https://github.com/Netflix/Hystrix/wiki#problem" target="_blank" rel="noopener noreferrer">Hystrix</a> is an example solution trying to address the problems of synchronous request/response. It comes <a href="https://github.com/Netflix/Hystrix/wiki/FAQ#what-is-the-processing-overhead-of-using-hystrix" target="_blank" rel="noopener noreferrer">at a cost</a> however in overhead and complexity.</p><p>Additionally, a poorly chosen communication protocol wastes server resources (CPU, memory, and network bandwidth). While that may be acceptable for smaller deployments, large systems with hundreds or thousands of nodes multiply small inefficiencies into noticeable excess. Running with a huge footprint leaves less room for expansion, as server resources are relatively cheap but not infinite. Managing giant clusters is much more expensive and less nimble even with good tools. And an often forgotten point is that the larger a cluster is, the more operationally complex it is, which becomes an availability concern.</p><p>RSocket seeks to:</p><ul><li><p>Reduce perceived latency and increase system efficiency by supporting non-blocking, duplex, async application communication with flow control over multiple transports from any language.</p></li><li><p>Reduce hardware footprint (and thus cost and operational complexity) by:</p><ul><li>increasing CPU and memory efficiency through use of binary encoding</li><li>avoiding redundant work by allowing persistent connections</li></ul></li><li><p>Reduce perceived user latency by:</p><ul><li>avoiding handshakes and the associated round-trip network overhead</li><li>reducing computation time by using binary encoding</li><li>allocating less memory and reducing garbage collection cost</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor anchor__h2 anchorWithStickyNavbar_31ik" id="comparisons"></a>Comparisons<a class="hash-link" href="#comparisons" title="Direct link to heading">#</a></h2><p>Following is a brief review of some protocols we reviewed before we decided to create RSocket. It does not attempt to be exhaustive or detailed. It also does not seek to criticize the various protocols, as they all are good at what they are built for. This section is meant solely to express that existing protocols did not sufficiently meet the requirements that motivated the creation of RSocket.</p><p>For context:</p><ul><li>RSocket is an OSI Layer 5/6, or TCP/IP ‚ÄúApplication Layer‚Äù protocol.</li><li>It is intended for use over duplex, binary transport protocols that are TCP-like in behavior (described further <a href="http://rsocket.io/about/Protocol#transport-protocol" target="_blank" rel="noopener noreferrer">here</a>).</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="tcp--quic"></a>TCP &amp; QUIC<a class="hash-link" href="#tcp--quic" title="Direct link to heading">#</a></h3><ul><li>No framing or application semantics</li><li>Must provide an application protocol</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="websockets"></a>WebSockets<a class="hash-link" href="#websockets" title="Direct link to heading">#</a></h3><ul><li>No application semantics, just framing</li><li>Must provide an application protocol</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor anchor__h3 anchorWithStickyNavbar_31ik" id="http11--http2"></a>HTTP/1.1 &amp; HTTP/2<a class="hash-link" href="#http11--http2" title="Direct link to heading">#</a></h3><p>HTTP provides barely-sufficient raw capabilities for application protocols to be built with, but an application protocol still needs to be defined on top of it. It is insufficient in defining application semantics. (<a href="https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md" target="_blank" rel="noopener noreferrer">gRPC from Google</a> is an example of a protocol being built on top of HTTP/2 to add these type of semantics).</p><p>These limited application semantics generally require an application protocol to define things such as:</p><ul><li>Use of GET, POST, or PUT for request</li><li>Use of Normal, Chunked, or SSE for response</li><li>MimeType of payload</li><li>Error messaging along with standard status codes</li><li>How the client should behave with status codes</li><li>Use of SSE as persistent channel from server to client to allow server to make requests to client</li></ul><p>There is no defined mechanism for flow control from responder (typically server) to requester (typically client). HTTP/2 does flow control at the byte level, not the application level. The mechanisms for communicating requester (typically server) availability (such as failing a request) are inefficient and painful. It does not support interaction models such as fire-and-forget, and streaming models are inefficient (chunked encoding or SSE, which is <span style="font-size:90%">ASCII</span>-based).</p><p>Despite its ubiquity, <span style="font-size:90%">REST</span> alone is insufficient and inappropriate for defining application semantics.</p><p>What about HTTP/2 though? Doesn‚Äôt it resolve the HTTP/1 issues and address the motivations of RSocket?</p><p>Unfortunately, no. HTTP/2 is <em>much</em> better for browsers and request/response document transfer, but does not expose the desired behaviors and interaction models for applications as described earlier in this document.</p><p>Here are some quotes from the HTTP/2 <a href="https://http2.github.io/http2-spec/" target="_blank" rel="noopener noreferrer">spec</a> and <a href="https://http2.github.io/faq/" target="_blank" rel="noopener noreferrer">FAQ</a> that are useful to provide context on what HTTP/2 was targeting:</p><blockquote><p>‚ÄúHTTP‚Äôs existing semantics remain unchanged.‚Äù</p></blockquote><blockquote><p>‚Äú‚Ä¶¬†from the application perspective, the features of the protocol are largely unchanged¬†‚Ä¶‚Äù</p></blockquote><blockquote><p>‚ÄúThis effort was chartered to work on a revision of the wire protocol‚Äâ‚Äî‚Äâi.e., how HTTP headers, methods, etc. are put ‚Äòonto the wire‚Äô, not change HTTP‚Äôs semantics.‚Äù</p></blockquote><p>Additionally, ‚Äúpush promises‚Äù are focused on filling browser caches for standard web browsing behavior:</p><blockquote><p>‚ÄúPushed responses are always associated with an explicit request from the client.‚Äù</p></blockquote><p>This means we still need SSE or WebSockets (and SSE is a text protocol so requires Base64 encoding to UTF-8) for push.</p><p>HTTP/2 was meant as a better HTTP/1.1, primarily for document retrieval in browsers for websites. We can do better than HTTP/2 for applications.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/rsocket/rsocket-website/edit/master/content-docs/about/motivations.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_13-_"><span class="theme-last-updated">Last updated on <b><time datetime="2022-05-08T19:34:10.000Z">5/8/2022</time></b> by <b>Gabriel Shaar</b></span></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/about/faq"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">¬´ FAQ</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/about/protocol"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Protocol ¬ª</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#message-driven" class="table-of-contents__link">Message Driven</a></li><li><a href="#interaction-models" class="table-of-contents__link">Interaction Models</a><ul><li><a href="#fire-and-forget" class="table-of-contents__link">Fire-and-Forget</a></li><li><a href="#requestresponse-single-response" class="table-of-contents__link">Request/Response (single-response)</a></li><li><a href="#requeststream-multi-response-finite" class="table-of-contents__link">Request/Stream (multi-response, finite)</a></li><li><a href="#channel" class="table-of-contents__link">Channel</a></li></ul></li><li><a href="#behaviors" class="table-of-contents__link">Behaviors</a><ul><li><a href="#single-response-vs-multi-response" class="table-of-contents__link">Single-Response vs. Multi-Response</a></li><li><a href="#bi-directional" class="table-of-contents__link">Bi-Directional</a></li></ul></li><li><a href="#cancellation" class="table-of-contents__link">Cancellation</a></li><li><a href="#resumability" class="table-of-contents__link">Resumability</a></li><li><a href="#application-flow-control" class="table-of-contents__link">Application Flow Control</a><ul><li><a href="#reactive-streams-requestn-async-pull" class="table-of-contents__link">‚ÄúReactive Streams‚Äù <code>request(n)</code> Async Pull</a></li><li><a href="#leasing" class="table-of-contents__link">Leasing</a></li></ul></li><li><a href="#polyglot-support" class="table-of-contents__link">Polyglot Support</a></li><li><a href="#transport-layer-flexibility" class="table-of-contents__link">Transport Layer Flexibility</a></li><li><a href="#efficiency--performance" class="table-of-contents__link">Efficiency &amp; Performance</a></li><li><a href="#comparisons" class="table-of-contents__link">Comparisons</a><ul><li><a href="#tcp--quic" class="table-of-contents__link">TCP &amp; QUIC</a></li><li><a href="#websockets" class="table-of-contents__link">WebSockets</a></li><li><a href="#http11--http2" class="table-of-contents__link">HTTP/1.1 &amp; HTTP/2</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://twitter.com/RSocketIO" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div></div><div class="footer__bottom text--center"><div class="margin-bottom--sm"><img src="/img/r-socket-pink.svg" alt="RSocket Logo" class="themedImage_1VuW themedImage--light_3UqQ footer__logo"><img src="/img/r-socket-pink.svg" alt="RSocket Logo" class="themedImage_1VuW themedImage--dark_hz6m footer__logo"></div><div class="footer__copyright">Copyright ¬© 2022 RSocket Contributors</div></div></div></footer></div>
<script src="/assets/js/runtime~main.bd5a8bb2.js"></script>
<script src="/assets/js/main.d9d3646b.js"></script>
</body>
</html>